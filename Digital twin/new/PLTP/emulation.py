
# 输出
# [
#     [[起点，终点，时间，级数],[起点，终点，时间，级数]],
#     [[起点，终点，时间，级数],[起点，终点，时间，级数]]
# ] 按级数顺序由小到大(起点只有那几个上货点)

# 1. 打通点，构建只具有上货点与交通点的树(保留交通点 --9-8-5 保留 --9-5)
# 2. 按路径时间由长到短 给上货点排序

# 算法步骤:
# 1.取各交通点停留时间和最短间距时间最大值 t0 记录最大值所在点
# 2.计算各上货点到记录的点的时间（不算该点的停留时间与最短间距时间）
# 3.由大到小排序，按此顺序到达推出上货时刻

#中间点、根节点停留时间，交通点最短防撞时间 用变量代替
#
#求最大停时间
#自己编停留时间啥的，用变量存
# 17号写完并整合并测试

#建树
#读入列表
#格式 [[]]   // [[级数1]、[级数2]、[级数3]、[级数4]]

# 输入格式
# graph_of_spots = [
#     [1, 10, 9, 2.5],  // [ 级数, 起点(id), 终点(id), 时间]
#     [1, 11, 9, 2.1],
#     [2, 9, 5, 2.3],
#     [3, 4, 2, 2.4],
#     [3, 5, 2, 1.5],
#     [3, 6, 2, 1.4],
#     [4, 2, 1, 2,5],
#     [6, 1, 3, 3],
#     [7, 3, 8, 3.4],
#     [7, 3, 7, 3.1]
# ]
#
# fold_id = 1  # 叠箱机的 id

# 打通
# 把所有情况压缩成 上货点 -> 上货点后的某个交通点 ,上货点后的某个交通点 -> 叠箱机
# 到交通点后，到叠箱机有且仅有一条最短路线
# 输出格式:[[[上货点1,首交通点][首交通点，叠箱机]] . . . . .]
# 记录途径点 [[上货点1到首交通点之间的途径点1,2,3...],[21,22,23...]]
# 交通点途径点 [1,2,3,....叠箱机]
# 途径点用来确定停留时间
# 输出格式路线用来记录途中所花费的时间

# 交通点到叠箱机路径为先算的最短的，再算上货点到交通点的最短

# org = [
#     [1, 10, 9, 2.5],
#     [1, 11, 9, 2.1],
#     [2, 9, 5, 2.3],
#     [3, 4, 2, 2.4],
#     [3, 5, 2, 1.5],
#     [3, 6, 2, 1.4],
#     [4, 2, 1, 2.5],
#     [6, 1, 3, 3],
#     [7, 3, 8, 3.4],
#     [7, 3, 7, 3.1]
# ]


graph_of_spots = [
    [1, 10, 9, 2.5],
    [1, 11, 9, 2.1],
    [2, 9, 5, 2.3],
    [3, 4, 2, 2.4],
    [3, 5, 2, 1.5],
    [3, 6, 2, 1.4],
    [4, 2, 1, 2.5],
    [6, 1, 3, 3],
    [7, 3, 8, 3.4],
    [7, 3, 7, 3.1]
]

fold_id = 1  # 叠箱机的 id

# set >= dict > list
def emu(org,die,tStop=[]):
    # 记录无入边的
    ru = set();
    # 存放上货点
    d0 = set();
    # 存放交通点
    tran = set();
    # 存树边
    ed = {};
    # 存边权
    t = {};
    # org.append([-1,-1,-1,-1]);
    for i in range(0,len(org)):
            ru.add(org[i][2]);
            ed[org[i][1]] = org[i][2];  # ed[起点]=[终点]
            t[org[i][1]]=org[i][3];
    # 找出上货点
    for i in range(0,len(org)):
        if(org[i][1] not in ru):
            d0.add(org[i][1]);
            # tran.add(ed[key]);
    # 假设已有叠箱机编号
    die = 1;
    # 首交通点 到 叠箱机
    # 直接全算，没算法
    res={};
    for i in d0:
        st = ed[i];
        if(st not in res):
            res[st] = 0;
            j=st;
            while(j!=die):
                res[st]+=t[j];
                #留待加停留时间
                j=ed[j];
    Liscross = [];
    for i in d0:
        tem=[];
        ttm=[];
        tem.append(i);
        tem.append(ed[i]);
        tem.append(t[i]);
        ttm.append(ed[i]);
        ttm.append(die);
        ttm.append(res[ed[i]]);
        Liscross.append([tem,ttm]);
    return Liscross;

aa = emu(graph_of_spots,fold_id);
print(aa);